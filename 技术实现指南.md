# H5粒子交互页面 - 技术实现指南

## 一、项目结构设计

### 1.1 推荐目录结构

```
h5-particle-project/
├── public/                      # 静态资源
│   ├── models/                  # 3D模型文件
│   │   ├── character.glb
│   │   └── scene-objects.glb
│   ├── textures/                # 粒子纹理
│   │   ├── particle.png
│   │   └── glow.png
│   ├── audio/                   # 音频文件
│   │   ├── bgm.mp3
│   │   └── click.mp3
│   └── favicon.ico
│
├── src/
│   ├── assets/                  # 资源文件
│   │   ├── images/
│   │   └── fonts/
│   │
│   ├── components/              # Vue组件
│   │   ├── common/              # 通用组件
│   │   │   ├── LoadingScreen.vue
│   │   │   └── AudioControl.vue
│   │   ├── welcome/             # 欢迎页组件
│   │   │   └── WelcomePage.vue
│   │   ├── scenes/              # 场景组件
│   │   │   ├── Scene1.vue
│   │   │   ├── Scene2.vue
│   │   │   └── ...
│   │   └── navigation/          # 导航组件
│   │       └── ProgressBar.vue
│   │
│   ├── three/                   # Three.js 相关
│   │   ├── ParticleSystem.js    # 粒子系统核心类
│   │   ├── SceneManager.js      # 场景管理器
│   │   ├── CameraController.js  # 相机控制
│   │   ├── particles/           # 粒子效果
│   │   │   ├── BackgroundParticles.js
│   │   │   ├── ShapeParticles.js
│   │   │   └── ModelParticles.js
│   │   └── utils/               # 工具函数
│   │       ├── modelLoader.js
│   │       └── particleHelper.js
│   │
│   ├── composables/             # Vue 3 组合式函数
│   │   ├── useScroll.js         # 滚动逻辑
│   │   ├── useParticles.js      # 粒子逻辑
│   │   └── useAudio.js          # 音频逻辑
│   │
│   ├── utils/                   # 通用工具
│   │   ├── device.js            # 设备检测
│   │   ├── performance.js       # 性能检测
│   │   └── math.js              # 数学工具
│   │
│   ├── config/                  # 配置文件
│   │   ├── scenes.js            # 场景配置
│   │   └── particles.js         # 粒子配置
│   │
│   ├── App.vue                  # 根组件
│   ├── main.js                  # 入口文件
│   └── style.css                # 全局样式
│
├── .env.development             # 开发环境变量
├── .env.production              # 生产环境变量
├── vite.config.js               # Vite 配置
├── package.json
└── README.md
```

---

## 二、核心代码实现示例

### 2.1 粒子系统核心类

```javascript
// src/three/ParticleSystem.js
import * as THREE from 'three';

export class ParticleSystem {
  constructor(scene, camera, renderer) {
    this.scene = scene;
    this.camera = camera;
    this.renderer = renderer;
    
    this.particleCount = this.getParticleCount();
    this.particles = null;
    this.particleGeometry = null;
    this.particleMaterial = null;
    
    this.init();
  }
  
  // 根据设备性能确定粒子数量
  getParticleCount() {
    const isMobile = /iPhone|iPad|Android/i.test(navigator.userAgent);
    const isLowEnd = window.devicePixelRatio < 2;
    
    if (isMobile && isLowEnd) {
      return 3000; // 低端移动设备
    } else if (isMobile) {
      return 5000; // 中端移动设备
    } else {
      return 10000; // 桌面设备
    }
  }
  
  init() {
    // 创建粒子几何体
    this.particleGeometry = new THREE.BufferGeometry();
    
    // 粒子位置
    const positions = new Float32Array(this.particleCount * 3);
    // 粒子颜色
    const colors = new Float32Array(this.particleCount * 3);
    // 粒子大小
    const sizes = new Float32Array(this.particleCount);
    
    for (let i = 0; i < this.particleCount; i++) {
      const i3 = i * 3;
      
      // 随机位置
      positions[i3] = (Math.random() - 0.5) * 100;
      positions[i3 + 1] = (Math.random() - 0.5) * 100;
      positions[i3 + 2] = (Math.random() - 0.5) * 100;
      
      // 颜色（渐变效果）
      const color = new THREE.Color();
      color.setHSL(Math.random() * 0.2 + 0.5, 0.7, 0.7);
      colors[i3] = color.r;
      colors[i3 + 1] = color.g;
      colors[i3 + 2] = color.b;
      
      // 随机大小
      sizes[i] = Math.random() * 2 + 0.5;
    }
    
    this.particleGeometry.setAttribute(
      'position',
      new THREE.BufferAttribute(positions, 3)
    );
    this.particleGeometry.setAttribute(
      'color',
      new THREE.BufferAttribute(colors, 3)
    );
    this.particleGeometry.setAttribute(
      'size',
      new THREE.BufferAttribute(sizes, 1)
    );
    
    // 加载粒子纹理
    const textureLoader = new THREE.TextureLoader();
    const particleTexture = textureLoader.load('/textures/particle.png');
    
    // 创建粒子材质
    this.particleMaterial = new THREE.PointsMaterial({
      size: 2,
      sizeAttenuation: true,
      map: particleTexture,
      transparent: true,
      alphaTest: 0.001,
      vertexColors: true,
      blending: THREE.AdditiveBlending, // 加法混合，发光效果
      depthWrite: false
    });
    
    // 创建粒子系统
    this.particles = new THREE.Points(
      this.particleGeometry,
      this.particleMaterial
    );
    
    this.scene.add(this.particles);
  }
  
  // 动画更新
  animate(time) {
    if (!this.particles) return;
    
    const positions = this.particleGeometry.attributes.position.array;
    
    for (let i = 0; i < this.particleCount; i++) {
      const i3 = i * 3;
      
      // 粒子浮动效果
      positions[i3 + 1] += Math.sin(time * 0.001 + i) * 0.01;
      
      // 粒子旋转
      const x = positions[i3];
      const z = positions[i3 + 2];
      const angle = Math.atan2(z, x) + 0.0005;
      const distance = Math.sqrt(x * x + z * z);
      
      positions[i3] = Math.cos(angle) * distance;
      positions[i3 + 2] = Math.sin(angle) * distance;
    }
    
    this.particleGeometry.attributes.position.needsUpdate = true;
  }
  
  // 清理
  dispose() {
    if (this.particleGeometry) this.particleGeometry.dispose();
    if (this.particleMaterial) this.particleMaterial.dispose();
    if (this.particles) this.scene.remove(this.particles);
  }
}
```

---

### 2.2 场景管理器

```javascript
// src/three/SceneManager.js
import * as THREE from 'three';
import { ParticleSystem } from './ParticleSystem';
import gsap from 'gsap';

export class SceneManager {
  constructor(canvas) {
    this.canvas = canvas;
    this.currentScene = 0;
    this.isTransitioning = false;
    
    this.initThree();
    this.initParticles();
    this.animate();
  }
  
  initThree() {
    // 场景
    this.scene = new THREE.Scene();
    this.scene.fog = new THREE.FogExp2(0x000000, 0.001);
    
    // 相机
    this.camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    this.camera.position.z = 50;
    
    // 渲染器
    this.renderer = new THREE.WebGLRenderer({
      canvas: this.canvas,
      antialias: true,
      alpha: true
    });
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    
    // 响应式
    window.addEventListener('resize', () => this.onResize());
  }
  
  initParticles() {
    this.particleSystem = new ParticleSystem(
      this.scene,
      this.camera,
      this.renderer
    );
  }
  
  // 切换场景
  transitionToScene(sceneIndex) {
    if (this.isTransitioning || sceneIndex === this.currentScene) return;
    
    this.isTransitioning = true;
    
    // 相机动画
    gsap.to(this.camera.position, {
      z: 30 + sceneIndex * 10,
      y: sceneIndex * 5,
      duration: 2,
      ease: 'power2.inOut',
      onComplete: () => {
        this.currentScene = sceneIndex;
        this.isTransitioning = false;
      }
    });
    
    // 可以在这里添加粒子形状变化的逻辑
  }
  
  onResize() {
    this.camera.aspect = window.innerWidth / window.innerHeight;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(window.innerWidth, window.innerHeight);
  }
  
  animate() {
    requestAnimationFrame(() => this.animate());
    
    const time = Date.now();
    this.particleSystem.animate(time);
    
    this.renderer.render(this.scene, this.camera);
  }
  
  dispose() {
    this.particleSystem.dispose();
    this.renderer.dispose();
  }
}
```

---

### 2.3 滚动交互 Composable

```javascript
// src/composables/useScroll.js
import { ref, onMounted, onUnmounted } from 'vue';
import { throttle } from 'lodash-es';

export function useScroll(sceneCount, onSceneChange) {
  const currentScene = ref(0);
  const scrollProgress = ref(0);
  
  let isScrolling = false;
  
  const handleScroll = throttle((event) => {
    if (isScrolling) return;
    
    const delta = event.deltaY;
    
    // 向下滚动
    if (delta > 0 && currentScene.value < sceneCount - 1) {
      isScrolling = true;
      currentScene.value++;
      onSceneChange(currentScene.value);
      
      setTimeout(() => {
        isScrolling = false;
      }, 1000);
    }
    // 向上滚动
    else if (delta < 0 && currentScene.value > 0) {
      isScrolling = true;
      currentScene.value--;
      onSceneChange(currentScene.value);
      
      setTimeout(() => {
        isScrolling = false;
      }, 1000);
    }
    
    // 更新进度
    scrollProgress.value = currentScene.value / (sceneCount - 1);
  }, 100);
  
  // 触摸事件处理
  let touchStartY = 0;
  
  const handleTouchStart = (event) => {
    touchStartY = event.touches[0].clientY;
  };
  
  const handleTouchEnd = (event) => {
    const touchEndY = event.changedTouches[0].clientY;
    const delta = touchStartY - touchEndY;
    
    if (Math.abs(delta) > 50) {
      handleScroll({ deltaY: delta });
    }
  };
  
  onMounted(() => {
    window.addEventListener('wheel', handleScroll, { passive: false });
    window.addEventListener('touchstart', handleTouchStart);
    window.addEventListener('touchend', handleTouchEnd);
  });
  
  onUnmounted(() => {
    window.removeEventListener('wheel', handleScroll);
    window.removeEventListener('touchstart', handleTouchStart);
    window.removeEventListener('touchend', handleTouchEnd);
  });
  
  return {
    currentScene,
    scrollProgress
  };
}
```

---

### 2.4 主应用组件

```vue
<!-- src/App.vue -->
<template>
  <div class="app">
    <!-- 加载屏幕 -->
    <LoadingScreen v-if="isLoading" :progress="loadingProgress" />
    
    <!-- 欢迎页 -->
    <WelcomePage 
      v-if="!isLoading && !hasStarted" 
      @start="handleStart"
    />
    
    <!-- 主内容 -->
    <div v-show="hasStarted" class="main-container">
      <!-- Three.js Canvas -->
      <canvas ref="canvasRef" class="webgl-canvas"></canvas>
      
      <!-- 场景内容覆盖层 -->
      <div class="scene-overlay">
        <transition name="fade" mode="out-in">
          <component 
            :is="currentSceneComponent" 
            :key="currentScene"
          />
        </transition>
      </div>
      
      <!-- 进度导航 -->
      <ProgressBar 
        :current="currentScene" 
        :total="sceneCount"
        @change="handleSceneChange"
      />
      
      <!-- 音频控制 -->
      <AudioControl v-model="audioEnabled" />
    </div>
  </div>
</template>

<script setup>
import { ref, computed, onMounted, onUnmounted, shallowRef } from 'vue';
import { SceneManager } from './three/SceneManager';
import { useScroll } from './composables/useScroll';
import LoadingScreen from './components/common/LoadingScreen.vue';
import WelcomePage from './components/welcome/WelcomePage.vue';
import ProgressBar from './components/navigation/ProgressBar.vue';
import AudioControl from './components/common/AudioControl.vue';

// 场景组件
import Scene1 from './components/scenes/Scene1.vue';
import Scene2 from './components/scenes/Scene2.vue';
import Scene3 from './components/scenes/Scene3.vue';
import Scene4 from './components/scenes/Scene4.vue';
import Scene5 from './components/scenes/Scene5.vue';
import SceneFinal from './components/scenes/SceneFinal.vue';

const sceneComponents = [Scene1, Scene2, Scene3, Scene4, Scene5, SceneFinal];
const sceneCount = sceneComponents.length;

// 状态
const isLoading = ref(true);
const loadingProgress = ref(0);
const hasStarted = ref(false);
const audioEnabled = ref(true);

// Canvas 引用
const canvasRef = ref(null);
let sceneManager = null;

// 当前场景组件
const currentSceneComponent = computed(() => {
  return sceneComponents[currentScene.value];
});

// 滚动交互
const { currentScene, scrollProgress } = useScroll(
  sceneCount,
  (sceneIndex) => {
    if (sceneManager) {
      sceneManager.transitionToScene(sceneIndex);
    }
  }
);

// 场景切换
const handleSceneChange = (sceneIndex) => {
  currentScene.value = sceneIndex;
  if (sceneManager) {
    sceneManager.transitionToScene(sceneIndex);
  }
};

// 开始体验
const handleStart = () => {
  hasStarted.value = true;
  
  // 初始化 Three.js 场景
  setTimeout(() => {
    if (canvasRef.value) {
      sceneManager = new SceneManager(canvasRef.value);
    }
  }, 100);
};

// 资源加载
const loadAssets = async () => {
  // 模拟资源加载
  for (let i = 0; i <= 100; i += 10) {
    await new Promise(resolve => setTimeout(resolve, 100));
    loadingProgress.value = i;
  }
  
  isLoading.value = false;
};

onMounted(() => {
  loadAssets();
});

onUnmounted(() => {
  if (sceneManager) {
    sceneManager.dispose();
  }
});
</script>

<style scoped>
.app {
  width: 100vw;
  height: 100vh;
  overflow: hidden;
  background: #000;
}

.main-container {
  position: relative;
  width: 100%;
  height: 100%;
}

.webgl-canvas {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 1;
}

.scene-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 2;
  pointer-events: none;
}

.fade-enter-active,
.fade-leave-active {
  transition: opacity 0.8s ease;
}

.fade-enter-from,
.fade-leave-to {
  opacity: 0;
}
</style>
```

---

### 2.5 设备性能检测

```javascript
// src/utils/performance.js

export class PerformanceDetector {
  static getDeviceLevel() {
    const ua = navigator.userAgent;
    const isMobile = /iPhone|iPad|Android/i.test(ua);
    const cores = navigator.hardwareConcurrency || 2;
    const memory = navigator.deviceMemory || 4; // GB
    
    let level = 'high';
    
    if (isMobile) {
      // 移动设备
      if (cores <= 4 || memory <= 2) {
        level = 'low';
      } else if (cores <= 6 || memory <= 4) {
        level = 'medium';
      }
    } else {
      // 桌面设备
      if (cores <= 2 || memory <= 4) {
        level = 'medium';
      }
    }
    
    return level;
  }
  
  static getParticleCount() {
    const level = this.getDeviceLevel();
    
    const counts = {
      low: 3000,
      medium: 6000,
      high: 12000
    };
    
    return counts[level];
  }
  
  static shouldUseSimplifiedEffects() {
    return this.getDeviceLevel() === 'low';
  }
  
  static testWebGLSupport() {
    try {
      const canvas = document.createElement('canvas');
      return !!(
        window.WebGLRenderingContext &&
        (canvas.getContext('webgl') || canvas.getContext('experimental-webgl'))
      );
    } catch (e) {
      return false;
    }
  }
}
```

---

## 三、关键技术要点

### 3.1 粒子性能优化技巧

#### 1. 使用 BufferGeometry
```javascript
// ❌ 性能差
const geometry = new THREE.Geometry();

// ✅ 性能好
const geometry = new THREE.BufferGeometry();
const positions = new Float32Array(count * 3);
geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
```

#### 2. 减少 Draw Calls
```javascript
// ✅ 使用 InstancedMesh 合并相同的粒子
const geometry = new THREE.SphereGeometry(0.1, 8, 8);
const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
const instancedMesh = new THREE.InstancedMesh(geometry, material, count);
```

#### 3. 粒子回收与对象池
```javascript
class ParticlePool {
  constructor(maxSize) {
    this.pool = [];
    this.maxSize = maxSize;
  }
  
  get() {
    return this.pool.pop() || this.create();
  }
  
  release(particle) {
    if (this.pool.length < this.maxSize) {
      this.pool.push(particle);
    }
  }
  
  create() {
    return { x: 0, y: 0, z: 0, vx: 0, vy: 0, vz: 0 };
  }
}
```

#### 4. 使用着色器进行GPU计算
```javascript
const vertexShader = `
  attribute float size;
  varying vec3 vColor;
  
  void main() {
    vColor = color;
    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
    gl_PointSize = size * (300.0 / -mvPosition.z);
    gl_Position = projectionMatrix * mvPosition;
  }
`;

const fragmentShader = `
  uniform sampler2D pointTexture;
  varying vec3 vColor;
  
  void main() {
    gl_FragColor = vec4(vColor, 1.0);
    gl_FragColor = gl_FragColor * texture2D(pointTexture, gl_PointCoord);
  }
`;
```

---

### 3.2 模型转粒子算法

```javascript
// src/three/utils/modelLoader.js
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';
import { MeshSurfaceSampler } from 'three/examples/jsm/math/MeshSurfaceSampler';
import * as THREE from 'three';

export async function loadModelAsParticles(modelPath, particleCount) {
  const loader = new GLTFLoader();
  
  return new Promise((resolve, reject) => {
    loader.load(
      modelPath,
      (gltf) => {
        const mesh = gltf.scene.children[0];
        
        // 使用 MeshSurfaceSampler 在模型表面采样
        const sampler = new MeshSurfaceSampler(mesh).build();
        
        const positions = new Float32Array(particleCount * 3);
        const tempPosition = new THREE.Vector3();
        
        for (let i = 0; i < particleCount; i++) {
          sampler.sample(tempPosition);
          positions[i * 3] = tempPosition.x;
          positions[i * 3 + 1] = tempPosition.y;
          positions[i * 3 + 2] = tempPosition.z;
        }
        
        resolve(positions);
      },
      undefined,
      reject
    );
  });
}
```

---

### 3.3 移动端适配要点

#### 1. 触摸事件处理
```javascript
// 防止页面滚动
document.addEventListener('touchmove', (e) => {
  e.preventDefault();
}, { passive: false });

// 处理触摸滑动
let touchStart = 0;
canvas.addEventListener('touchstart', (e) => {
  touchStart = e.touches[0].clientY;
});

canvas.addEventListener('touchend', (e) => {
  const touchEnd = e.changedTouches[0].clientY;
  const delta = touchStart - touchEnd;
  
  if (Math.abs(delta) > 50) {
    // 切换场景
  }
});
```

#### 2. 视口设置
```html
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
```

#### 3. iOS Safari 特殊处理
```javascript
// 修复 iOS 的 100vh 问题
const setVh = () => {
  const vh = window.innerHeight * 0.01;
  document.documentElement.style.setProperty('--vh', `${vh}px`);
};

window.addEventListener('resize', setVh);
setVh();
```

```css
.app {
  height: 100vh; /* fallback */
  height: calc(var(--vh, 1vh) * 100);
}
```

---

## 四、部署配置

### 4.1 Vite 配置优化

```javascript
// vite.config.js
import { defineConfig } from 'vite';
import vue from '@vitejs/plugin-vue';
import { compression } from 'vite-plugin-compression';

export default defineConfig({
  plugins: [
    vue(),
    // Gzip 压缩
    compression({
      algorithm: 'gzip',
      ext: '.gz'
    })
  ],
  
  build: {
    // 代码分割
    rollupOptions: {
      output: {
        manualChunks: {
          'three': ['three'],
          'gsap': ['gsap'],
          'vendor': ['vue']
        }
      }
    },
    
    // 资源内联限制
    assetsInlineLimit: 4096,
    
    // 生成 source map（生产环境建议关闭）
    sourcemap: false,
    
    // 压缩
    minify: 'terser',
    terserOptions: {
      compress: {
        drop_console: true,
        drop_debugger: true
      }
    }
  },
  
  // 优化依赖预构建
  optimizeDeps: {
    include: ['three', 'gsap', 'vue']
  }
});
```

---

### 4.2 资源优化

#### 1. 纹理压缩
- 使用 WebP 格式（体积减少 30-50%）
- 纹理尺寸控制在 512x512 或更小
- 使用工具: TinyPNG, Squoosh

#### 2. 模型优化
- GLTF 使用 Draco 压缩
- 减少多边形数量
- 移除不必要的材质和动画

```javascript
// 使用 Draco 解码器
import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader';

const dracoLoader = new DRACOLoader();
dracoLoader.setDecoderPath('/draco/');
gltfLoader.setDRACOLoader(dracoLoader);
```

#### 3. 懒加载
```javascript
// 预加载关键资源，懒加载非关键资源
const loadCriticalAssets = async () => {
  // 加载首屏资源
};

const loadSceneAssets = async (sceneIndex) => {
  // 按需加载场景资源
};
```

---

## 五、常见问题与解决方案

### Q1: 移动端粒子卡顿怎么办？
**A**: 
1. 降低粒子数量（3000以下）
2. 关闭部分效果（如发光、模糊）
3. 降低渲染分辨率：`renderer.setPixelRatio(1)`
4. 使用简化的粒子材质

### Q2: 如何实现粒子从一个形状变为另一个形状？
**A**:
```javascript
function morphParticles(fromPositions, toPositions, duration) {
  const positions = particleGeometry.attributes.position.array;
  
  gsap.to(positions, {
    duration,
    ease: 'power2.inOut',
    onUpdate: function() {
      const progress = this.progress();
      
      for (let i = 0; i < positions.length; i++) {
        positions[i] = fromPositions[i] + 
          (toPositions[i] - fromPositions[i]) * progress;
      }
      
      particleGeometry.attributes.position.needsUpdate = true;
    }
  });
}
```

### Q3: 如何检测设备是否支持 WebGL？
**A**:
```javascript
if (!PerformanceDetector.testWebGLSupport()) {
  // 显示降级提示
  showFallbackMessage();
  // 或使用 Canvas 2D 替代方案
  useCanvas2DFallback();
}
```

### Q4: 如何优化首屏加载速度？
**A**:
1. 关键资源预加载
2. 非关键资源懒加载
3. 使用 CDN
4. 启用 Gzip/Brotli 压缩
5. 代码分割
6. 使用 loading 占位符

---

## 六、开发工具推荐

### 6.1 调试工具
- **Three.js Inspector**: Chrome 插件，用于调试 Three.js 场景
- **Stats.js**: 性能监控（FPS, MS, MB）
- **dat.GUI**: 参数调试面板

```javascript
import Stats from 'three/examples/jsm/libs/stats.module';
import { GUI } from 'three/examples/jsm/libs/lil-gui.module.min';

// 性能监控
const stats = new Stats();
document.body.appendChild(stats.dom);

// 调试面板
const gui = new GUI();
gui.add(particleSystem, 'particleCount', 1000, 20000).step(1000);
gui.add(particleMaterial, 'size', 0.1, 5);
```

### 6.2 3D 建模工具
- **Blender**: 免费开源，功能强大
- **Cinema 4D**: 专业级，易上手
- **Three.js Editor**: 在线编辑器

### 6.3 设计工具
- **Figma**: UI设计
- **Principle**: 交互原型
- **After Effects**: 动效设计

---

## 七、学习资源

### 官方文档
- Three.js: https://threejs.org/docs/
- Vue 3: https://cn.vuejs.org/
- GSAP: https://greensock.com/docs/

### 教程推荐
- Three.js Journey: https://threejs-journey.com/
- WebGL Fundamentals: https://webglfundamentals.org/

### 示例项目
- Three.js Examples: https://threejs.org/examples/
- Awwwards 获奖作品: https://www.awwwards.com/

---

**文档版本**: v1.0  
**更新日期**: 2025-10-22

