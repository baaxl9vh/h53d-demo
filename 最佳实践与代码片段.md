# H5粒子交互页面 - 最佳实践与代码片段

## 一、资源加载最佳实践

### 1.1 渐进式资源加载管理器

```javascript
// src/utils/ResourceLoader.js
import * as THREE from 'three';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';

export class ResourceLoader {
  constructor() {
    this.loadingManager = new THREE.LoadingManager();
    this.textureLoader = new THREE.TextureLoader(this.loadingManager);
    this.gltfLoader = new GLTFLoader(this.loadingManager);
    
    this.totalItems = 0;
    this.loadedItems = 0;
    this.resources = {};
    
    this.setupLoadingManager();
  }
  
  setupLoadingManager() {
    this.loadingManager.onStart = (url, itemsLoaded, itemsTotal) => {
      console.log(`开始加载: ${url}`);
      this.totalItems = itemsTotal;
    };
    
    this.loadingManager.onProgress = (url, itemsLoaded, itemsTotal) => {
      this.loadedItems = itemsLoaded;
      const progress = (itemsLoaded / itemsTotal) * 100;
      console.log(`加载进度: ${progress.toFixed(2)}%`);
      
      // 触发进度事件
      this.onProgress?.(progress, itemsLoaded, itemsTotal);
    };
    
    this.loadingManager.onLoad = () => {
      console.log('所有资源加载完成');
      this.onComplete?.();
    };
    
    this.loadingManager.onError = (url) => {
      console.error(`加载失败: ${url}`);
      this.onError?.(url);
    };
  }
  
  // 加载纹理
  async loadTexture(name, url) {
    return new Promise((resolve, reject) => {
      this.textureLoader.load(
        url,
        (texture) => {
          this.resources[name] = texture;
          resolve(texture);
        },
        undefined,
        reject
      );
    });
  }
  
  // 加载模型
  async loadModel(name, url) {
    return new Promise((resolve, reject) => {
      this.gltfLoader.load(
        url,
        (gltf) => {
          this.resources[name] = gltf;
          resolve(gltf);
        },
        undefined,
        reject
      );
    });
  }
  
  // 批量加载资源
  async loadAll(assets) {
    const promises = [];
    
    for (const asset of assets) {
      if (asset.type === 'texture') {
        promises.push(this.loadTexture(asset.name, asset.url));
      } else if (asset.type === 'model') {
        promises.push(this.loadModel(asset.name, asset.url));
      }
    }
    
    return Promise.all(promises);
  }
  
  // 获取资源
  get(name) {
    return this.resources[name];
  }
  
  // 清理资源
  dispose() {
    Object.values(this.resources).forEach(resource => {
      if (resource.dispose) {
        resource.dispose();
      }
    });
    this.resources = {};
  }
}

// 使用示例
const loader = new ResourceLoader();

loader.onProgress = (progress) => {
  console.log(`Loading: ${progress}%`);
};

loader.onComplete = () => {
  console.log('All assets loaded!');
};

const assets = [
  { type: 'texture', name: 'particle', url: '/textures/particle.png' },
  { type: 'texture', name: 'glow', url: '/textures/glow.png' },
  { type: 'model', name: 'character', url: '/models/character.glb' }
];

await loader.loadAll(assets);
```

---

## 二、粒子形状生成器

### 2.1 从图片生成粒子位置

```javascript
// src/three/utils/imageToParticles.js

export async function imageToParticles(imagePath, particleCount, scale = 1) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = 'Anonymous';
    
    img.onload = () => {
      // 创建临时 canvas
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      canvas.width = img.width;
      canvas.height = img.height;
      
      // 绘制图片
      ctx.drawImage(img, 0, 0);
      
      // 获取像素数据
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const pixels = imageData.data;
      
      // 收集非透明像素位置
      const positions = [];
      for (let y = 0; y < canvas.height; y++) {
        for (let x = 0; x < canvas.width; x++) {
          const i = (y * canvas.width + x) * 4;
          const alpha = pixels[i + 3];
          
          // 只保留非透明像素
          if (alpha > 128) {
            positions.push({
              x: (x - canvas.width / 2) * scale,
              y: -(y - canvas.height / 2) * scale, // Y轴反转
              z: 0,
              color: {
                r: pixels[i] / 255,
                g: pixels[i + 1] / 255,
                b: pixels[i + 2] / 255
              }
            });
          }
        }
      }
      
      // 如果粒子太多，进行采样
      if (positions.length > particleCount) {
        const step = Math.floor(positions.length / particleCount);
        const sampled = [];
        for (let i = 0; i < positions.length; i += step) {
          sampled.push(positions[i]);
        }
        resolve(sampled);
      } else {
        resolve(positions);
      }
    };
    
    img.onerror = reject;
    img.src = imagePath;
  });
}

// 使用示例
const particleData = await imageToParticles('/images/logo.png', 5000, 0.1);

// 创建粒子系统
const geometry = new THREE.BufferGeometry();
const positions = new Float32Array(particleData.length * 3);
const colors = new Float32Array(particleData.length * 3);

particleData.forEach((p, i) => {
  positions[i * 3] = p.x;
  positions[i * 3 + 1] = p.y;
  positions[i * 3 + 2] = p.z;
  
  colors[i * 3] = p.color.r;
  colors[i * 3 + 1] = p.color.g;
  colors[i * 3 + 2] = p.color.b;
});

geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
```

---

### 2.2 常见几何形状粒子生成器

```javascript
// src/three/utils/shapeGenerators.js
import * as THREE from 'three';

export const ShapeGenerators = {
  // 球形
  sphere(count, radius = 10) {
    const positions = new Float32Array(count * 3);
    
    for (let i = 0; i < count; i++) {
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);
      
      const x = radius * Math.sin(phi) * Math.cos(theta);
      const y = radius * Math.sin(phi) * Math.sin(theta);
      const z = radius * Math.cos(phi);
      
      positions[i * 3] = x;
      positions[i * 3 + 1] = y;
      positions[i * 3 + 2] = z;
    }
    
    return positions;
  },
  
  // 立方体
  cube(count, size = 10) {
    const positions = new Float32Array(count * 3);
    
    for (let i = 0; i < count; i++) {
      positions[i * 3] = (Math.random() - 0.5) * size;
      positions[i * 3 + 1] = (Math.random() - 0.5) * size;
      positions[i * 3 + 2] = (Math.random() - 0.5) * size;
    }
    
    return positions;
  },
  
  // 圆环
  torus(count, radius = 10, tube = 3) {
    const positions = new Float32Array(count * 3);
    
    for (let i = 0; i < count; i++) {
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.random() * Math.PI * 2;
      
      const x = (radius + tube * Math.cos(phi)) * Math.cos(theta);
      const y = tube * Math.sin(phi);
      const z = (radius + tube * Math.cos(phi)) * Math.sin(theta);
      
      positions[i * 3] = x;
      positions[i * 3 + 1] = y;
      positions[i * 3 + 2] = z;
    }
    
    return positions;
  },
  
  // 螺旋
  helix(count, radius = 10, height = 20, turns = 5) {
    const positions = new Float32Array(count * 3);
    
    for (let i = 0; i < count; i++) {
      const t = i / count;
      const angle = t * Math.PI * 2 * turns;
      
      const x = radius * Math.cos(angle);
      const y = height * (t - 0.5);
      const z = radius * Math.sin(angle);
      
      positions[i * 3] = x;
      positions[i * 3 + 1] = y;
      positions[i * 3 + 2] = z;
    }
    
    return positions;
  },
  
  // 文字形状（使用 Canvas）
  text(text, count, fontSize = 80) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    canvas.width = 512;
    canvas.height = 256;
    
    ctx.fillStyle = 'white';
    ctx.font = `bold ${fontSize}px Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, canvas.width / 2, canvas.height / 2);
    
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const pixels = imageData.data;
    
    const positions = [];
    for (let y = 0; y < canvas.height; y += 2) {
      for (let x = 0; x < canvas.width; x += 2) {
        const i = (y * canvas.width + x) * 4;
        if (pixels[i] > 128) {
          positions.push(
            (x - canvas.width / 2) * 0.05,
            -(y - canvas.height / 2) * 0.05,
            0
          );
        }
      }
    }
    
    // 采样到指定数量
    const step = Math.max(1, Math.floor(positions.length / 3 / count));
    const result = new Float32Array(count * 3);
    let index = 0;
    
    for (let i = 0; i < positions.length && index < count * 3; i += step * 3) {
      result[index++] = positions[i];
      result[index++] = positions[i + 1];
      result[index++] = positions[i + 2];
    }
    
    return result;
  }
};

// 使用示例
const spherePositions = ShapeGenerators.sphere(5000, 15);
const textPositions = ShapeGenerators.text('HELLO', 3000);
```

---

## 三、粒子动画系统

### 3.1 粒子变形动画类

```javascript
// src/three/particles/ParticleMorph.js
import gsap from 'gsap';

export class ParticleMorph {
  constructor(particleGeometry) {
    this.geometry = particleGeometry;
    this.currentPositions = null;
    this.isAnimating = false;
  }
  
  // 形状变换
  morphTo(targetPositions, duration = 2, ease = 'power2.inOut') {
    if (this.isAnimating) return;
    
    this.isAnimating = true;
    const positions = this.geometry.attributes.position.array;
    const startPositions = [...positions]; // 拷贝当前位置
    
    // 确保目标位置数组长度匹配
    const minLength = Math.min(positions.length, targetPositions.length);
    
    return new Promise((resolve) => {
      gsap.to({ progress: 0 }, {
        progress: 1,
        duration,
        ease,
        onUpdate: function() {
          const progress = this.targets()[0].progress;
          
          for (let i = 0; i < minLength; i++) {
            positions[i] = startPositions[i] + 
              (targetPositions[i] - startPositions[i]) * progress;
          }
          
          this.geometry.attributes.position.needsUpdate = true;
        },
        onUpdateParams: [this],
        onComplete: () => {
          this.isAnimating = false;
          this.currentPositions = targetPositions;
          resolve();
        }
      });
    });
  }
  
  // 爆炸效果
  explode(strength = 5, duration = 1) {
    const positions = this.geometry.attributes.position.array;
    const velocities = new Float32Array(positions.length);
    
    // 计算每个粒子的速度方向（从中心向外）
    for (let i = 0; i < positions.length; i += 3) {
      const x = positions[i];
      const y = positions[i + 1];
      const z = positions[i + 2];
      
      const length = Math.sqrt(x * x + y * y + z * z) || 1;
      
      velocities[i] = (x / length) * strength;
      velocities[i + 1] = (y / length) * strength;
      velocities[i + 2] = (z / length) * strength;
    }
    
    // 应用速度
    return new Promise((resolve) => {
      gsap.to({ time: 0 }, {
        time: 1,
        duration,
        ease: 'power2.out',
        onUpdate: function() {
          const t = this.targets()[0].time;
          
          for (let i = 0; i < positions.length; i++) {
            positions[i] += velocities[i] * t;
          }
          
          this.geometry.attributes.position.needsUpdate = true;
        },
        onUpdateParams: [this],
        onComplete: resolve
      });
    });
  }
  
  // 波浪效果
  wave(amplitude = 2, frequency = 0.5, duration = 3) {
    const positions = this.geometry.attributes.position.array;
    const originalY = [...positions].filter((_, i) => (i + 2) % 3 === 0); // 保存原始Y值
    
    let startTime = Date.now();
    
    const animate = () => {
      if (Date.now() - startTime > duration * 1000) return;
      
      const time = (Date.now() - startTime) / 1000;
      
      for (let i = 0; i < positions.length; i += 3) {
        const x = positions[i];
        const z = positions[i + 2];
        const index = i / 3;
        
        positions[i + 1] = originalY[index] + 
          Math.sin(x * frequency + time * 2) * amplitude +
          Math.sin(z * frequency + time * 2) * amplitude;
      }
      
      this.geometry.attributes.position.needsUpdate = true;
      requestAnimationFrame(animate);
    };
    
    animate();
  }
}

// 使用示例
const morph = new ParticleMorph(particleGeometry);

// 变形到球形
const spherePositions = ShapeGenerators.sphere(5000, 15);
await morph.morphTo(spherePositions, 2);

// 爆炸
await morph.explode(10, 1.5);

// 波浪效果
morph.wave(3, 0.3, 5);
```

---

## 四、性能监控与优化

### 4.1 性能监控工具类

```javascript
// src/utils/PerformanceMonitor.js

export class PerformanceMonitor {
  constructor() {
    this.fps = 0;
    this.frameTime = 0;
    this.memory = 0;
    
    this.lastTime = performance.now();
    this.frames = 0;
    this.fpsInterval = 1000; // 每秒更新一次
    this.fpsLastUpdate = this.lastTime;
    
    this.callbacks = [];
  }
  
  // 开始监控
  start() {
    this.update();
  }
  
  update() {
    const currentTime = performance.now();
    this.frameTime = currentTime - this.lastTime;
    this.lastTime = currentTime;
    
    // 计算 FPS
    this.frames++;
    if (currentTime - this.fpsLastUpdate >= this.fpsInterval) {
      this.fps = Math.round(
        (this.frames * 1000) / (currentTime - this.fpsLastUpdate)
      );
      this.frames = 0;
      this.fpsLastUpdate = currentTime;
      
      // 获取内存使用（如果支持）
      if (performance.memory) {
        this.memory = Math.round(
          performance.memory.usedJSHeapSize / 1048576 // 转换为 MB
        );
      }
      
      // 触发回调
      this.callbacks.forEach(cb => cb({
        fps: this.fps,
        frameTime: this.frameTime,
        memory: this.memory
      }));
    }
    
    requestAnimationFrame(() => this.update());
  }
  
  // 添加监听器
  onChange(callback) {
    this.callbacks.push(callback);
  }
  
  // 获取当前性能等级
  getPerformanceLevel() {
    if (this.fps >= 50) return 'high';
    if (this.fps >= 30) return 'medium';
    return 'low';
  }
  
  // 性能警告
  shouldReduceQuality() {
    return this.fps < 25; // 低于25fps建议降低质量
  }
}

// 使用示例
const monitor = new PerformanceMonitor();

monitor.onChange((stats) => {
  console.log(`FPS: ${stats.fps}, Memory: ${stats.memory}MB`);
  
  // 根据性能自动调整
  if (monitor.shouldReduceQuality()) {
    console.warn('Performance low, reducing particle count...');
    // 降低粒子数量或质量
    particleSystem.reduceParticles();
  }
});

monitor.start();
```

---

### 4.2 自适应性能优化

```javascript
// src/three/AdaptiveQuality.js

export class AdaptiveQuality {
  constructor(scene, particleSystem) {
    this.scene = scene;
    this.particleSystem = particleSystem;
    
    this.qualityLevels = {
      high: {
        particleCount: 12000,
        enablePostProcessing: true,
        shadowQuality: 'high',
        pixelRatio: Math.min(window.devicePixelRatio, 2)
      },
      medium: {
        particleCount: 6000,
        enablePostProcessing: false,
        shadowQuality: 'medium',
        pixelRatio: 1.5
      },
      low: {
        particleCount: 3000,
        enablePostProcessing: false,
        shadowQuality: 'low',
        pixelRatio: 1
      }
    };
    
    this.currentQuality = 'high';
  }
  
  // 设置质量级别
  setQuality(level) {
    if (!this.qualityLevels[level]) return;
    
    const settings = this.qualityLevels[level];
    this.currentQuality = level;
    
    // 调整粒子数量
    this.particleSystem.setParticleCount(settings.particleCount);
    
    // 调整渲染分辨率
    this.renderer.setPixelRatio(settings.pixelRatio);
    
    // 开启/关闭后处理效果
    this.togglePostProcessing(settings.enablePostProcessing);
    
    console.log(`Quality set to: ${level}`);
  }
  
  // 自动调整质量
  autoAdjust(fps) {
    if (fps >= 50 && this.currentQuality !== 'high') {
      this.setQuality('high');
    } else if (fps >= 30 && fps < 50 && this.currentQuality !== 'medium') {
      this.setQuality('medium');
    } else if (fps < 30 && this.currentQuality !== 'low') {
      this.setQuality('low');
    }
  }
  
  togglePostProcessing(enable) {
    // 实现后处理效果的开关
    if (enable) {
      // 启用效果
    } else {
      // 禁用效果
    }
  }
}
```

---

## 五、移动端触摸交互

### 5.1 手势识别系统

```javascript
// src/utils/GestureRecognizer.js

export class GestureRecognizer {
  constructor(element) {
    this.element = element;
    this.touchStartX = 0;
    this.touchStartY = 0;
    this.touchStartTime = 0;
    this.isSwiping = false;
    
    this.minSwipeDistance = 50; // 最小滑动距离
    this.maxSwipeTime = 300; // 最大滑动时间（快速滑动）
    
    this.callbacks = {
      swipeUp: [],
      swipeDown: [],
      swipeLeft: [],
      swipeRight: [],
      tap: [],
      longPress: []
    };
    
    this.init();
  }
  
  init() {
    this.element.addEventListener('touchstart', (e) => this.handleTouchStart(e));
    this.element.addEventListener('touchmove', (e) => this.handleTouchMove(e));
    this.element.addEventListener('touchend', (e) => this.handleTouchEnd(e));
  }
  
  handleTouchStart(e) {
    const touch = e.touches[0];
    this.touchStartX = touch.clientX;
    this.touchStartY = touch.clientY;
    this.touchStartTime = Date.now();
    
    // 长按检测
    this.longPressTimer = setTimeout(() => {
      this.trigger('longPress', { x: this.touchStartX, y: this.touchStartY });
    }, 500);
  }
  
  handleTouchMove(e) {
    this.isSwiping = true;
    clearTimeout(this.longPressTimer);
    
    // 可以在这里添加实时拖拽逻辑
  }
  
  handleTouchEnd(e) {
    clearTimeout(this.longPressTimer);
    
    const touch = e.changedTouches[0];
    const touchEndX = touch.clientX;
    const touchEndY = touch.clientY;
    const touchEndTime = Date.now();
    
    const deltaX = touchEndX - this.touchStartX;
    const deltaY = touchEndY - this.touchStartY;
    const deltaTime = touchEndTime - this.touchStartTime;
    
    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    
    // 点击
    if (!this.isSwiping && distance < 10 && deltaTime < 200) {
      this.trigger('tap', { x: touchEndX, y: touchEndY });
      this.isSwiping = false;
      return;
    }
    
    // 滑动
    if (distance >= this.minSwipeDistance) {
      const angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;
      
      if (angle >= -45 && angle < 45) {
        this.trigger('swipeRight', { distance, deltaTime });
      } else if (angle >= 45 && angle < 135) {
        this.trigger('swipeDown', { distance, deltaTime });
      } else if (angle >= -135 && angle < -45) {
        this.trigger('swipeUp', { distance, deltaTime });
      } else {
        this.trigger('swipeLeft', { distance, deltaTime });
      }
    }
    
    this.isSwiping = false;
  }
  
  // 注册回调
  on(event, callback) {
    if (this.callbacks[event]) {
      this.callbacks[event].push(callback);
    }
  }
  
  // 触发事件
  trigger(event, data) {
    if (this.callbacks[event]) {
      this.callbacks[event].forEach(cb => cb(data));
    }
  }
}

// 使用示例
const gesture = new GestureRecognizer(document.body);

gesture.on('swipeUp', () => {
  console.log('向上滑动');
  sceneManager.nextScene();
});

gesture.on('swipeDown', () => {
  console.log('向下滑动');
  sceneManager.previousScene();
});

gesture.on('tap', (data) => {
  console.log('点击', data);
});
```

---

## 六、音效管理系统

### 6.1 音频管理器

```javascript
// src/utils/AudioManager.js

export class AudioManager {
  constructor() {
    this.sounds = {};
    this.bgm = null;
    this.enabled = true;
    this.volume = 1.0;
    this.bgmVolume = 0.5;
    this.sfxVolume = 0.7;
    
    // 检测用户交互后才能播放音频（移动端限制）
    this.isUnlocked = false;
    this.unlockAudio();
  }
  
  // 解锁音频（移动端需要）
  unlockAudio() {
    const unlock = () => {
      const sound = new Audio();
      sound.src = 'data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4Ljc2LjEwMAAAAAAAAAAAAAAA//tQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAACAAADhAC7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7//////////////////////////////////////////////////////////////////8AAAAATGF2YzU4LjEzAAAAAAAAAAAAAAAAJAAAAAAAAAAAA4S+gMgwAAAAAAD/+xDEAAPAAAGkAAAAIAAANIAAAARMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV';
      sound.play();
      this.isUnlocked = true;
      
      document.removeEventListener('touchstart', unlock);
      document.removeEventListener('click', unlock);
    };
    
    document.addEventListener('touchstart', unlock);
    document.addEventListener('click', unlock);
  }
  
  // 加载音效
  load(name, url, isLoop = false) {
    const audio = new Audio(url);
    audio.loop = isLoop;
    audio.volume = isLoop ? this.bgmVolume : this.sfxVolume;
    
    this.sounds[name] = {
      audio,
      isLoop
    };
    
    return new Promise((resolve, reject) => {
      audio.addEventListener('canplaythrough', () => resolve(audio));
      audio.addEventListener('error', reject);
    });
  }
  
  // 播放音效
  play(name) {
    if (!this.enabled || !this.sounds[name]) return;
    
    const { audio } = this.sounds[name];
    audio.currentTime = 0;
    audio.play().catch(e => console.warn('Audio play failed:', e));
  }
  
  // 播放背景音乐
  playBGM(name) {
    if (!this.enabled || !this.sounds[name]) return;
    
    this.stopBGM(); // 停止当前背景音乐
    
    const { audio } = this.sounds[name];
    this.bgm = audio;
    audio.play().catch(e => console.warn('BGM play failed:', e));
  }
  
  // 停止背景音乐
  stopBGM() {
    if (this.bgm) {
      this.bgm.pause();
      this.bgm.currentTime = 0;
    }
  }
  
  // 暂停/恢复
  toggle() {
    this.enabled = !this.enabled;
    
    if (this.enabled) {
      if (this.bgm) this.bgm.play();
    } else {
      Object.values(this.sounds).forEach(({ audio }) => audio.pause());
    }
  }
  
  // 设置音量
  setVolume(volume) {
    this.volume = Math.max(0, Math.min(1, volume));
    
    Object.values(this.sounds).forEach(({ audio, isLoop }) => {
      audio.volume = this.volume * (isLoop ? this.bgmVolume : this.sfxVolume);
    });
  }
}

// 使用示例
const audioManager = new AudioManager();

// 加载音频
await Promise.all([
  audioManager.load('bgm', '/audio/bgm.mp3', true),
  audioManager.load('click', '/audio/click.mp3'),
  audioManager.load('swoosh', '/audio/swoosh.mp3')
]);

// 播放
audioManager.playBGM('bgm');
audioManager.play('click');
```

---

## 七、调试工具集成

### 7.1 开发调试面板

```javascript
// src/utils/DebugPanel.js
import { GUI } from 'three/examples/jsm/libs/lil-gui.module.min';
import Stats from 'three/examples/jsm/libs/stats.module';

export class DebugPanel {
  constructor(sceneManager, particleSystem) {
    this.sceneManager = sceneManager;
    this.particleSystem = particleSystem;
    
    // 只在开发环境显示
    if (import.meta.env.MODE !== 'development') return;
    
    this.initStats();
    this.initGUI();
  }
  
  initStats() {
    this.stats = new Stats();
    this.stats.dom.style.position = 'absolute';
    this.stats.dom.style.top = '0';
    this.stats.dom.style.left = '0';
    document.body.appendChild(this.stats.dom);
  }
  
  initGUI() {
    this.gui = new GUI();
    
    // 粒子设置
    const particleFolder = this.gui.addFolder('Particles');
    particleFolder.add(
      this.particleSystem.particleMaterial,
      'size',
      0.1,
      10
    ).name('粒子大小');
    
    particleFolder.add(
      { count: this.particleSystem.particleCount },
      'count',
      1000,
      20000
    ).step(1000).name('粒子数量').onChange((value) => {
      this.particleSystem.setParticleCount(value);
    });
    
    // 相机设置
    const cameraFolder = this.gui.addFolder('Camera');
    cameraFolder.add(this.sceneManager.camera.position, 'x', -100, 100).name('X');
    cameraFolder.add(this.sceneManager.camera.position, 'y', -100, 100).name('Y');
    cameraFolder.add(this.sceneManager.camera.position, 'z', -100, 100).name('Z');
    
    // 场景设置
    const sceneFolder = this.gui.addFolder('Scene');
    sceneFolder.add(
      { scene: 0 },
      'scene',
      0,
      5
    ).step(1).name('当前场景').onChange((value) => {
      this.sceneManager.transitionToScene(value);
    });
    
    // 性能设置
    const perfFolder = this.gui.addFolder('Performance');
    perfFolder.add(
      this.sceneManager.renderer,
      'shadowMap'
    ).name('启用阴影');
  }
  
  update() {
    if (this.stats) {
      this.stats.update();
    }
  }
  
  destroy() {
    if (this.gui) this.gui.destroy();
    if (this.stats) {
      document.body.removeChild(this.stats.dom);
    }
  }
}
```

---

## 八、总结

这些代码片段和最佳实践涵盖了：

1. ✅ **资源加载**: 渐进式加载、进度跟踪
2. ✅ **粒子生成**: 从图片、几何形状、文字生成粒子
3. ✅ **动画系统**: 变形、爆炸、波浪等效果
4. ✅ **性能优化**: 监控、自适应质量调整
5. ✅ **移动端交互**: 手势识别、触摸事件
6. ✅ **音效管理**: 完整的音频系统
7. ✅ **调试工具**: 开发调试面板

### 使用建议

1. **按需引入**: 不要全部使用，根据项目需求选择
2. **性能优先**: 移动端务必做好性能优化
3. **渐进增强**: 先实现核心功能，再添加特效
4. **充分测试**: 在各种设备上测试效果

---

**版本**: v1.0  
**更新日期**: 2025-10-22

